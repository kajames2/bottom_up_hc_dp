#+begin_src plantuml :file hcdp_uml.png
package "Health Care"{
  Harvest ..> HealthState
  NullHarvest --|> Harvest
  FlatHarvest --|> Harvest
  LinearHarvest --|> Harvest
  RetirementHarvest --|> Harvest
  CompositeHarvest --> NullHarvest
  CompositeHarvest o--|> Harvest

  LinearDegeneration --|> Degeneration

  HealthInvestmentStateFactory --> Degeneration
  HealthInvestmentStateFactory --> Harvest
  HealthInvestmentStateFactory --> HealthState
  
  IncreasingDecayConsumption --|> Consumption
  
  LogisticRegeneration --|> Regeneration
  
  PeriodResultFactory --> Consumption
  PeriodResultFactory --> Regeneration
  PeriodResultFactory --> HealthState
  PeriodResultFactory --> Investment
  PeriodResultFactory --> PeriodResult

  PeriodResult --> Investment
  PeriodResult --> HealthState
}

class HealthState {
  + int period
  + int health
  + int cash
  + int total_working_harvest
  + bool IsAlive()
}

class Investment {
  + int health_investment
  + int life_investment
}

class PeriodResult {
  + HealthState state
  + Investment investment
  + double life_enjoyment
}

abstract class Harvest {
  + bool InRange(int period) const
  + int GetHarvest(HealthState state) const
  + int GetWorkingHarvest(HealthState state) const
}

package "DP" {
  DP ..> DPStorage
  DP ..> DecisionOptimizer
  DP ..> ExogenousFactory
  DP ..> StateIterator
  DecisionOptimizer --> EndogenousIteratorFactory
  DecisionOptimizer --> ExogenousState

  EndogenousIteratorFactory ..> EndogenousIterator
  DPStorage --> EndogenousState
}

abstract class ExogenousFactory<T> {
  ExogenousState<T> GetExogenous(T)
}

abstract class DP<T> {
  - unique_ptr<DPStorage<T>> storage_
  - void Train()
  - vector<EndogenousState<T>> GetSolution(T start_state)
}

class DecisionOptimizer<T> {
  + pair<EndogenousState<T>, double> FindOptimal(ExogenousState<T> intermediate)
}

abstract class DPStorage<T> {
  + const EndogenousState<T>& GetOptimalDecision(T)
  + double GetOptimalValue(T)
  + bool IsEndState(T)
}

abstract class StateIterator<T> {

}

class ExogenousState<T> {
  T state;
}

class EndogenousState<T> {
  T state;
  double value;
}

abstract class EndogenousIterator<T> {
  + explicit operator bool() const
  + EndogenousState<T> const& operator*() const
  + EndogenousState<T> const* operator->() const
  + virtual DecisionIterator<EndogenousState<T>>& operator++()

  - bool done_;
  - T state_;
}

abstract class EndogenousIteratorFactory<T> {
  + DecisionIterator<EndogenousState<T>> GetIterator(ExogenousState<T>)
}

package "Health Care DP" {
  HealthDPStorage --|> DPStorage
  HealthStateIterator --|> StateIterator
  HealthStateIterator ..> HealthState

  EndogenousResultIterator --|> EndogenousIterator
  EndogenousResultIterator ..> ResultToEndogenousAdapter
  EndogenousResultIterator ..> ResultToEndogenousAdapterFactory
  EndogenousResultIteratorFactory --|> EndogenousIteratorFactory
  EndogenousResultIteratorFactory ..> EndogenousResultIterator

  ResultToEndogenousAdapter --|> EndogenousState
  ResultToEndogenousAdapter ..> PeriodResult
  ResultToEndogenousAdapterFactory ..> PeriodResultFactory
  ResultToEndogenousAdapterFactory --> ResultToEndogenousAdapter

  HealthStateToExogenousAdapterFactory --|> ExogenousFactory
  HealthStateToExogenousAdapterFactory --> HealthStateToExogenousAdapter
  HealthStateToExogenousAdapterFactory ..> HealthInvestmentStateFactory
  HealthStateToExogenousAdapter --|> ExogenousState
  HealthStateToExogenousAdapter ..> HealthState
}

abstract class HealthDPStorage {
  + const EndogenousHealthState& GetOptimalDecision(HealthState)
  + double GetOptimalValue(HealthState)
  + bool IsEndState(HealthState)

  - vector<vector<vector<EndogenousHealthState>>> state_table_
  - vector<vector<vector<double>>> value_table_
}
class EndogenousResultIterator {

}

class EndogenousResultIteratorFactory {
  + InvestmentIteratorFactory()
  + InvestmentIterator GetIterator(HealthState)
}

class HealthStateIterator {

}

#+end_src

#+RESULTS:
[[file:hcdp_uml.png]]
